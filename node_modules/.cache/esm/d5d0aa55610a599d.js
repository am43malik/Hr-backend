let Joi,User,bcrypt,JWT;_610‍.x([["default",()=>_610‍.o]]);_610‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);_610‍.w("../../model/authmodle/user",[["default",["User"],function(v){User=v}]]);_610‍.w("bcrypt",[["default",["bcrypt"],function(v){bcrypt=v}]]);_610‍.w("../../services/Jwt",[["default",["JWT"],function(v){JWT=v}]]);






const LoginSchema = {
  async login(req, res, next) {
    const loginSchema = Joi.object({
      email: Joi.string().email().required(),
      password: Joi.string(),
    });

    const { error } = loginSchema.validate(req.body);
    if (error) {
      return next(error);
    }

    //--------------chack user-------------
    let AccessToken;
    let loginUser
    try {
       loginUser = await User.findOne({ email: req.body.email });

      if (!loginUser) {
        return next(Error("User and Password are not found"));
      }
    } catch (error) {
      return next(error);
    }
    //-------------match password---------------------
    _610‍.g.console.log(loginUser)

    const match =  bcrypt.compare(req.body.password, loginUser.password);

    if (!match) {
      return next(Error("User and Password are Wrong"));
    }

    AccessToken = JWT.sign({ _id: loginUser._id });
    res.json({ AccessToken });
  },
};
_610‍.d(LoginSchema);
