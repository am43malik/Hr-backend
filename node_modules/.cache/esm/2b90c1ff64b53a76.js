let Joi,CustomErrorHandler,User,bcrypt,hash,JWT;_64b‍.x([["default",()=>_64b‍.o]]);_64b‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);_64b‍.w("../services/CustomErrorHandler",[["default",["CustomErrorHandler"],function(v){CustomErrorHandler=v}]]);_64b‍.w("../model/authmodle/user",[["default",["User"],function(v){User=v}]]);_64b‍.w("bcrypt",[["default",["bcrypt"],function(v){bcrypt=v}],["hash",["hash"],function(v){hash=v}]]);_64b‍.w("../services/Jwt",[["default",["JWT"],function(v){JWT=v}]]);





const registerSchema = {
  async register(req, res, next) {
    const { name, email, password } = req.body;

    const RegisterSchema = Joi.object({
      name: Joi.string().required(),
      email: Joi.string().email().required(),
      password: Joi.string(),
    });

    const { error } = RegisterSchema.validate(req.body);
    if (error) {
      return next(error);
    }

    ///------check database user already exsit.-----------------------

    try {
      const exist = await User.exists({ email: email });

      if (exist) {
        return next(Error("User Already Exist."));
      }
    } catch (err) {
      return next(err);
    }

    //--------hashed password-----------

    const hashedPassword = await bcrypt.hash(password, 10);

    //==========modle save in a badabase--------------------

    const user = new User({
      name,
      email,
      password: hashedPassword,
    });
    let AccessToken;
    try {
      const result = await user.save();
      AccessToken = JWT.sign({ _id: result._id });
    } catch (err) {
      return next(err);
    }

    return res.json(user);
  },

 
};

_64b‍.d(registerSchema);
